#!/bin/lua
local version = "v0.6"

--===== load libs =====--
package.path = "libs/?.lua;" .. package.path

local lip = require("LIP")
local ut = require("UT")
local argparse = require("argparse")
local lfs = require("lfs")

local conf = lip.load("ltrs.ini")

--===== parse args =====--
local args
do
    local parser = argparse("ltrs", "LifeTimedRSnapshot")
    
    parser:argument("tasks", "Tasks to do"):args("*"):target("tasks")
    
    parser:flag("-v --version", "Shows the ltrs version and exit."):action(function() 
        print("ltrs: " .. version)
        os.exit(0)
    end)

    parser:flag("-k --keep", "Keep the auto generatet temporary rsnapshot conf files."):target("keepTmpRsConfFiles")

    parser:option("-c --conf", "Alternative ltrs config file.", "ltrs.ini"):target("confFile")
    parser:option("-s --rsconf", "Alternative rsnapshot config file.", "rsnapshot.conf"):target("rsConfFile")
    parser:option("-a --args", "Gives following args to rsnapshot."):target("rsArgs")

    args = parser:parse()
end

--===== load configs =====--
local tmpConfPath = "./tmp/"

local rsnapshotConf
local conf 

if lfs.attributes(args.rsConfFile) == nil then
    io.stderr:write("[FATAL]: Cant find rsnapshot config file\n")
    os.exit(1)
else
    rsnapshotConf = ut.readFile("rsnapshot.conf")
end

if lfs.attributes(args.confFile) == nil then
    io.stderr:write("[FATAL]: Cant find ltrs config file\n")
    os.exit(1)
else
    conf = lip.load(args.confFile)
end

-- debug
--print(ut.tostring(args))
--print(ut.tostring(conf))

--do return true end

--===== functions =====--
local function exec(task, name)
    local suc = select(3, os.execute(task))

    name = ut.parseArgs(name, "exec")

    if suc ~= 0 then
        io.stderr:write("[ERROR]: " .. name .. ": returned an error: " .. tostring(suc) .. "\n")
        
        return false, suc
    end

    return true, suc
end

local function rsConfBackupEnding(s)
    local ending = "\t.\n"

    if string.find(s, "\t") ~= nil then
        ending = "\n"
    end

    return ending
end

local function getTask(taskName)
    local task = conf[taskName]
    if type(task) == "table" then
        task.name = taskName
    end
    return task
end

local function getSnapshotAmount(task, allRetainsExisting, alternativePath)
    local amount = task.amount
    local path = task.snapshotPath

    if alternativePath then
        path = alternativePath
    end

    if tostring(amount) == "-1" then 
        amount = 0
        if lfs.attributes(path) == nil then
            exec("mkdir -p " .. path)
        end
        for fileName in lfs.dir(path) do
            local ending
            for s in string.gmatch(fileName, "[^.]+") do
                ending = s
            end

            if ending ~= nil and string.sub(fileName, 0, -(string.len(ending) +2)) == task.name then
                if tonumber(ending) > amount then
                    amount = tonumber(ending)
                end
            end
        end

        if allRetainsExisting then
            amount = amount +1
        else
            amount = amount +2
        end
    end

    return amount
end

local function prepareRsConf(task, allRetainsExisting)
    local tmpRsConf = rsnapshotConf
    local amount = getSnapshotAmount(task, allRetainsExisting)

    tmpRsConf = tmpRsConf .. "snapshot_root\t" .. task.snapshotPath .. "\nretain\t" .. task.name .. "\t" .. amount .. "\n"

    return tmpRsConf
end

local function inherit(task, tmpRsConf, internalData)
    -- pre exec
    -- human error check
    if task.getFrom ~= nil then
        if task.getFrom ~= nil or true then --necessary?
            if task.remotePath ~= nil or task.remotePathList ~= nil then
                print("[WARNING]: 'getFrom' is set in the task ’" .. task.name .. "’. 'remotePath' as well as 'remotePathList’ will be ignored!")

                task.remotePathList = nil
            end
            if task.snapshotPath ~= nil then
                print("[WARNING]: 'getFrom' is set in the task ’" .. task.name .. "’. 'snapshotPath' will be ignored. 'snapshotPath' from the '" .. task.getFrom .. "' task will be used instead")
            end
        end
        if conf[task.getFrom] == nil then 
            io.stderr:write("[ERROR]: Task '" .. task.name .. "’ tries to getFrom '" .. task.getFrom .. "'. but '" .. task.getFrom .. "' is not defined in '" .. args.confFile .. "'\n")
            return false
        end
        if task.getFrom == task.name then 
            io.stderr:write("[ERROR]: Task '" .. task.name .. "’ tries to getFrom itself. Thats not a legal option\n")
            return false
        end
    end
    if internalData and internalData.taskList and internalData.taskList[task.name] then
        io.stderr:write("[ERROR]: getFrom loop. Cant process task '" .. taskList.firstTask .. "'!\n")
        return false
    end
    -- exec
    local motherTask = getTask(task.getFrom)

    if internalData == nil then
        internalData = {
            taskList = {
                firstTask = task.name,
            },
            originalTask = task.name,
        }
    end
    internalData.taskList[task.name] = true

    if task.getFrom ~= nil then
        _, tmpRsConf = inherit(motherTask, nil, internalData)
        if tmpRsConf == false then
            return false
        end
    else
        internalData.motherTask = task
    end

    if task.getFrom == nil then
        tmpRsConf = prepareRsConf(task, true)
    else    
        local amount = getSnapshotAmount(task, true, internalData.motherTask.snapshotPath)
        if task.name == internalData.originalTask then
            amount = amount +1
        end
        print(task.name, amount)

        tmpRsConf = tmpRsConf .. "retain\t" .. task.name .. "\t" .. amount .. "\n"
    end

    return true, tmpRsConf, internalData.motherTask
end

--===== pre execution =====--
if lfs.attributes(tmpConfPath) == nil then
    exec("mkdir -p " .. tmpConfPath)
end

--===== start executing tasks =====--
local hasExecutetTasks = false
for _, taskName in ipairs(args.tasks) do
    hasExecutetTasks = true
    if getTask(taskName) ~= nil then
        local task = getTask(taskName)
        local tmpRsConfFile = io.open(tmpConfPath .. taskName, "w")
        local tmpRsConf

        if task.getFrom == nil then
            tmpRsConf = prepareRsConf(task, false)
        else
            local suc, trsc, motherTask = inherit(task)
            tmpRsConf = trsc
            local newTask = {}

            for i, c in pairs(task) do
                newTask[i] = c
            end

            task = newTask
            task.snapshotPath = motherTask.snapshotPath
            task.remotePath = motherTask.remotePath
            task.remotePathList = motherTask.remotePathList

            if suc == false then
                goto post_exec
            end
        end


        if task.remotePath ~= nil then
            tmpRsConf = tmpRsConf ..  "backup\t" .. task.remotePath .. rsConfBackupEnding(task.remotePath)
        end

        if lfs.attributes(task.remotePathList or "") ~= nil then
            for line in io.lines(task.remotePathList) do
                tmpRsConf = tmpRsConf .. "backup\t" .. line .. rsConfBackupEnding(line)
            end
        end

        tmpRsConfFile:write(tmpRsConf)
        tmpRsConfFile:close()

        if exec("rsnapshot " .. args.rsArgs .. " -c " .. tmpConfPath .. taskName .. " " .. taskName, "rsnapshot") then
            exec("find " .. task.snapshotPath .. " -maxdepth 1 -mtime +" .. task.lifeTime .. " -exec rm -r {} \\;", "find")
            
            if args.keepTmpRsConfFiles ~= true then
                exec("rm " .. tmpConfPath .. taskName, "rm")
            end
        end

        ::post_exec::
    else
        io.stderr:write("[ERROR]: Task '" .. taskName .. "' is not defined in '" .. args.confFile .. "'\n")
    end
end
if not hasExecutetTasks and args.rsArgs ~= nil then
    exec("rsnapshot " .. args.rsArgs)
end
